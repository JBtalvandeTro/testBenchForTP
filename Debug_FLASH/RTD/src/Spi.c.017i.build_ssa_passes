Spi_JobTransferFinished (const struct Spi_JobConfigType * JobConfig, Spi_JobResultType JobResult)
{
  uint32 SpiCoreID;
  Spi_JobType JobId;
  const struct Spi_JobConfigType * CurrentJobConfig;
  const Spi_JobType * Job;
  const struct Spi_SequenceConfigType * SequenceConfig;
  struct Spi_SequenceStateType * SequenceState;
  struct Spi_JobStateType * JobState;
  struct Spi_HWUnitQueue * HWUnitQueue;
  Spi_HWUnitType HWUnit;

  <bb 2> :
  HWUnit = JobConfig->HWUnit;
  _1 = (int) HWUnit;
  HWUnitQueue = &Spi_axSpiHwUnitQueueArray[_1];
  JobState = JobConfig->JobState;
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02 ();
  _2 = JobState->Result;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 3> :
  _3 = JobState->AsyncCrtSequenceState;
  if (_3 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 4> :
  JobState->Result = JobResult;
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02 ();
  SpiCoreID = JobConfig->SpiCoreUse;
  SequenceState = JobState->AsyncCrtSequenceState;
  SequenceConfig = SequenceState->Sequence;
  JobState->AsyncCrtSequenceState = 0B;
  _4 = JobConfig->EndNotification;
  if (_4 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _5 = JobConfig->EndNotification;
  _5 ();

  <bb 6> :
  _6 = JobState->Result;
  if (_6 == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _7 = SequenceState->Result;
  if (_7 != 3)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SequenceState->Result = 2;

  <bb 9> :
  _8 = SequenceState->Result;
  if (_8 == 3)
    goto <bb 11>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _9 = SequenceState->Result;
  if (_9 == 2)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _10 = SequenceState->RemainingJobs;
  Spi_UnlockRemainingJobs (_10, SequenceConfig);
  _11 = SequenceConfig->EndNotification;
  if (_11 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _12 = SequenceConfig->EndNotification;
  _12 ();

  <bb 13> :
  Spi_ScheduleNextJob (HWUnitQueue, SpiCoreID);
  goto <bb 21>; [INV]

  <bb 14> :
  _13 = SequenceState->RemainingJobs;
  if (_13 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  SequenceState->Result = 0;
  _14 = SequenceConfig->EndNotification;
  if (_14 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _15 = SequenceConfig->EndNotification;
  _15 ();

  <bb 17> :
  Spi_ScheduleNextJob (HWUnitQueue, SpiCoreID);
  goto <bb 21>; [INV]

  <bb 18> :
  _16 = SequenceState->CurrentJobIndexPointer;
  _17 = _16 + 2;
  SequenceState->CurrentJobIndexPointer = _17;
  Job = SequenceState->CurrentJobIndexPointer;
  JobId = *Job;
  _18 = SequenceState->RemainingJobs;
  _19 = _18;
  _20 = _19 + 65535;
  SequenceState->RemainingJobs = _20;
  _21 = Spi_apxSpiConfigPtr[SpiCoreID];
  _22 = _21->JobConfig;
  _23 = (unsigned int) JobId;
  _24 = _23 * 4;
  _25 = _22 + _24;
  CurrentJobConfig = _25->JobCfg;
  _26 = CurrentJobConfig->HWUnit;
  if (HWUnit != _26)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _27 = CurrentJobConfig->HWUnit;
  _28 = (int) _27;
  _29 = &Spi_axSpiHwUnitQueueArray[_28];
  Spi_ScheduleJob (_29, JobId, CurrentJobConfig);
  Spi_ScheduleNextJob (HWUnitQueue, SpiCoreID);
  goto <bb 21>; [INV]

  <bb 20> :
  _30 = (int) JobId;
  Spi_axSpiJobState[_30].Result = 1;
  HWUnitQueue->Channel = 0;
  HWUnitQueue->Job = JobId;
  Spi_Ipw_JobTransfer (CurrentJobConfig);

  <bb 21> :
  goto <bb 23>; [INV]

  <bb 22> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02 ();

  <bb 23> :
  return;

}


Spi_ScheduleNextJob (struct Spi_HWUnitQueue * HWUnitQueue, uint32 SpiCoreID)
{
  sint8 MaxScheduledPriority;
  sint8 Priority;
  Spi_JobType * JobListHead;
  Spi_JobType Job;

  <bb 2> :
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01 ();
  MaxScheduledPriority = HWUnitQueue->MaxScheduledPriority;
  if (MaxScheduledPriority < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  HWUnitQueue->Status = 1;
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01 ();
  goto <bb 12>; [INV]

  <bb 4> :
  _1 = (int) MaxScheduledPriority;
  JobListHead = &HWUnitQueue->ScheduledJobsListHead[_1];
  Job = *JobListHead;
  _2 = (int) Job;
  _3 = Spi_axSpiJobState[_2].AsyncNextJob;
  *JobListHead = _3;
  _4 = *JobListHead;
  if (_4 == 65535)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  _5 = (int) MaxScheduledPriority;
  HWUnitQueue->ScheduledJobsListTail[_5] = 65535;
  MaxScheduledPriority.20_6 = (unsigned char) MaxScheduledPriority;
  _7 = MaxScheduledPriority.20_6 + 255;
  Priority = (sint8) _7;
  goto <bb 9>; [INV]

  <bb 6> :
  _8 = (int) Priority;
  _9 = HWUnitQueue->ScheduledJobsListHead[_8];
  if (_9 != 65535)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  goto <bb 10>; [INV]

  <bb 8> :
  Priority.21_10 = Priority;
  Priority.22_11 = (unsigned char) Priority.21_10;
  _12 = Priority.22_11 + 255;
  Priority = (sint8) _12;

  <bb 9> :
  if (Priority >= 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  HWUnitQueue->MaxScheduledPriority = Priority;

  <bb 11> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01 ();
  _13 = (int) Job;
  Spi_axSpiJobState[_13].Result = 1;
  HWUnitQueue->Channel = 0;
  HWUnitQueue->Job = Job;
  _14 = Spi_apxSpiConfigPtr[SpiCoreID];
  _15 = _14->JobConfig;
  _16 = (unsigned int) Job;
  _17 = _16 * 4;
  _18 = _15 + _17;
  _19 = _18->JobCfg;
  Spi_Ipw_JobTransfer (_19);

  <bb 12> :
  return;

}


Spi_MainFunction_Handling ()
{
  uint32 SpiCoreID;
  Spi_HWUnitType HWUnit;

  <bb 2> :
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 3> :
  HWUnit = 0;
  goto <bb 9>; [INV]

  <bb 4> :
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->HWUnitConfig;
  _4 = (unsigned int) HWUnit;
  _5 = _4 * 4;
  _6 = _3 + _5;
  _7 = _6->PhyUnitConfig;
  if (_7 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _8 = Spi_apxSpiConfigPtr[SpiCoreID];
  _9 = _8->HWUnitConfig;
  _10 = (unsigned int) HWUnit;
  _11 = _10 * 4;
  _12 = _9 + _11;
  _13 = _12->PhyUnitConfig;
  _14 = _13->SpiCoreUse;
  if (SpiCoreID == _14)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _15 = (int) HWUnit;
  _16 = Spi_axSpiHwUnitQueueArray[_15].Status;
  if (_16 == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Spi_Ipw_IrqPoll (HWUnit, SpiCoreID);

  <bb 8> :
  HWUnit.19_17 = HWUnit;
  HWUnit = HWUnit.19_17 + 1;

  <bb 9> :
  if (HWUnit <= 2)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  return;

}


Spi_SetHWUnitAsyncMode (Spi_HWUnitType HWUnit, Spi_AsyncModeType AsyncMode)
{
  uint32 SpiCoreID;
  Std_ReturnType Status;
  Std_ReturnType D.6563;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->HWUnitConfig;
  _3 = (unsigned int) HWUnit;
  _4 = _3 * 4;
  _5 = _2 + _4;
  _6 = _5->PhyUnitConfig;
  _7 = _6->IsSync;
  if (_7 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Status = 1;
  goto <bb 7>; [INV]

  <bb 4> :
  _8 = (int) HWUnit;
  _9 = Spi_axSpiHwUnitQueueArray[_8].Status;
  if (_9 == 2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Status = 1;
  goto <bb 7>; [INV]

  <bb 6> :
  Spi_Ipw_IrqConfig (HWUnit, AsyncMode, SpiCoreID);

  <bb 7> :
  D.6563 = Status;

  <bb 8> :
<L6>:
  return D.6563;

}


Spi_SetAsyncMode (Spi_AsyncModeType Mode)
{
  uint32 SpiCoreID;
  Std_ReturnType Status;
  Spi_HWUnitType HWUnit;
  Std_ReturnType D.6541;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = Spi_GetAsyncStatus ();
  if (_1 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Status = 1;
  goto <bb 11>; [INV]

  <bb 4> :
  HWUnit = 0;
  goto <bb 10>; [INV]

  <bb 5> :
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->HWUnitConfig;
  _4 = (unsigned int) HWUnit;
  _5 = _4 * 4;
  _6 = _3 + _5;
  _7 = _6->PhyUnitConfig;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _8 = Spi_apxSpiConfigPtr[SpiCoreID];
  _9 = _8->HWUnitConfig;
  _10 = (unsigned int) HWUnit;
  _11 = _10 * 4;
  _12 = _9 + _11;
  _13 = _12->PhyUnitConfig;
  _14 = _13->SpiCoreUse;
  if (SpiCoreID == _14)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _15 = Spi_apxSpiConfigPtr[SpiCoreID];
  _16 = _15->HWUnitConfig;
  _17 = (unsigned int) HWUnit;
  _18 = _17 * 4;
  _19 = _16 + _18;
  _20 = _19->PhyUnitConfig;
  _21 = _20->IsSync;
  if (_21 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Spi_Ipw_IrqConfig (HWUnit, Mode, SpiCoreID);

  <bb 9> :
  HWUnit.17_22 = HWUnit;
  HWUnit = HWUnit.17_22 + 1;

  <bb 10> :
  if (HWUnit <= 2)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  D.6541 = Status;

  <bb 12> :
<L13>:
  return D.6541;

}


Spi_Cancel (Spi_SequenceType Sequence)
{
  <bb 2> :
  _1 = (int) Sequence;
  Spi_axSpiSequenceState[_1].Result = 3;
  return;

}


Spi_GetHWUnitStatus (Spi_HWUnitType HWUnit)
{
  Spi_StatusType Status;
  Spi_StatusType D.6529;

  <bb 2> :
  Status = 0;
  _1 = (int) HWUnit;
  Status = Spi_axSpiHwUnitQueueArray[_1].Status;
  D.6529 = Status;

  <bb 3> :
<L0>:
  return D.6529;

}


Spi_SyncTransmit (Spi_SequenceType Sequence)
{
  uint32 SpiCoreID;
  const struct Spi_JobConfigType * JobConfig;
  Spi_JobType Job;
  Spi_JobType NumJobsInSequence;
  const struct Spi_SequenceConfigType * SequenceConfig;
  Spi_JobType JobIndex;
  Spi_HWUnitType HWUnit;
  Std_ReturnType Status;
  struct Spi_SequenceStateType * SequenceState;
  Std_ReturnType D.6527;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->SequenceConfig;
  _3 = (unsigned int) Sequence;
  _4 = _3 * 4;
  _5 = _2 + _4;
  SequenceConfig = _5->SeqConfig;
  NumJobsInSequence = SequenceConfig->NumJobs;
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06 ();
  HWUnit = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _6 = (int) HWUnit;
  _7 = Spi_au32SpiBusySyncHWUnitsStatus[_6];
  _8 = (int) HWUnit;
  _9 = _7 << _8;
  _10 = (int) Sequence;
  _11 = Spi_au32SpiSeqUsedHWUnits[_10];
  _12 = _9 & _11;
  if (_12 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Status = 1;

  <bb 5> :
  HWUnit.14_13 = HWUnit;
  HWUnit = HWUnit.14_13 + 1;

  <bb 6> :
  if (HWUnit <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (Status != 1)
    goto <bb 8>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 8> :
  _14 = (int) Sequence;
  SequenceState = &Spi_axSpiSequenceState[_14];
  SequenceState->Result = 1;
  JobIndex = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  _15 = SequenceConfig->JobIndexList;
  _16 = (unsigned int) JobIndex;
  _17 = _16 * 2;
  _18 = _15 + _17;
  Job = *_18;
  _19 = Spi_apxSpiConfigPtr[SpiCoreID];
  _20 = _19->JobConfig;
  _21 = (unsigned int) Job;
  _22 = _21 * 4;
  _23 = _20 + _22;
  JobConfig = _23->JobCfg;
  HWUnit = JobConfig->HWUnit;
  _24 = (int) HWUnit;
  Spi_au32SpiBusySyncHWUnitsStatus[_24] = 1;
  JobIndex.15_25 = JobIndex;
  JobIndex = JobIndex.15_25 + 1;

  <bb 10> :
  if (JobIndex < NumJobsInSequence)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06 ();
  Status = Spi_SyncJobsTranfer (SequenceConfig, SpiCoreID);
  if (Status == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  SequenceState->Result = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  SequenceState->Result = 2;

  <bb 14> :
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07 ();
  JobIndex = 0;
  goto <bb 16>; [INV]

  <bb 15> :
  _26 = SequenceConfig->JobIndexList;
  _27 = (unsigned int) JobIndex;
  _28 = _27 * 2;
  _29 = _26 + _28;
  Job = *_29;
  _30 = Spi_apxSpiConfigPtr[SpiCoreID];
  _31 = _30->JobConfig;
  _32 = (unsigned int) Job;
  _33 = _32 * 4;
  _34 = _31 + _33;
  JobConfig = _34->JobCfg;
  HWUnit = JobConfig->HWUnit;
  _35 = (int) HWUnit;
  Spi_au32SpiBusySyncHWUnitsStatus[_35] = 0;
  JobIndex.16_36 = JobIndex;
  JobIndex = JobIndex.16_36 + 1;

  <bb 16> :
  if (JobIndex < NumJobsInSequence)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07 ();
  _37 = SequenceConfig->EndNotification;
  if (_37 != 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  _38 = SequenceConfig->EndNotification;
  _38 ();
  goto <bb 20>; [INV]

  <bb 19> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06 ();

  <bb 20> :
  D.6527 = Status;

  <bb 21> :
<L21>:
  return D.6527;

}


Spi_GetSequenceResult (Spi_SequenceType Sequence)
{
  Spi_SeqResultType SequenceResult;
  Spi_SeqResultType D.6513;

  <bb 2> :
  _1 = (int) Sequence;
  SequenceResult = Spi_axSpiSequenceState[_1].Result;
  D.6513 = SequenceResult;

  <bb 3> :
<L0>:
  return D.6513;

}


Spi_GetJobResult (Spi_JobType Job)
{
  Spi_JobResultType JobResult;
  Spi_JobResultType D.6511;

  <bb 2> :
  _1 = (int) Job;
  JobResult = Spi_axSpiJobState[_1].Result;
  D.6511 = JobResult;

  <bb 3> :
<L0>:
  return D.6511;

}


Spi_GetStatus ()
{
  uint32 SpiCoreID;
  Spi_HWUnitType HWUnit;
  Spi_StatusType StatusFlag;
  Spi_StatusType D.6509;

  <bb 2> :
  StatusFlag = 1;
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  StatusFlag = 0;
  goto <bb 13>; [INV]

  <bb 4> :
  HWUnit = 0;
  goto <bb 10>; [INV]

  <bb 5> :
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->HWUnitConfig;
  _4 = (unsigned int) HWUnit;
  _5 = _4 * 4;
  _6 = _3 + _5;
  _7 = _6->PhyUnitConfig;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _8 = Spi_apxSpiConfigPtr[SpiCoreID];
  _9 = _8->HWUnitConfig;
  _10 = (unsigned int) HWUnit;
  _11 = _10 * 4;
  _12 = _9 + _11;
  _13 = _12->PhyUnitConfig;
  _14 = _13->SpiCoreUse;
  if (SpiCoreID == _14)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _15 = (int) HWUnit;
  _16 = Spi_au32SpiBusySyncHWUnitsStatus[_15];
  if (_16 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  StatusFlag = 2;
  goto <bb 11>; [INV]

  <bb 9> :
  HWUnit.13_17 = HWUnit;
  HWUnit = HWUnit.13_17 + 1;

  <bb 10> :
  if (HWUnit <= 2)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  if (StatusFlag != 2)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  StatusFlag = Spi_GetStatusAsyncCheckHwBusy (SpiCoreID);

  <bb 13> :
  D.6509 = StatusFlag;

  <bb 14> :
<L16>:
  return D.6509;

}


Spi_SetupEB (Spi_ChannelType Channel, Spi_DataBufferType * SrcDataBufferPtr, Spi_DataBufferType * DesDataBufferPtr, Spi_NumberOfDataType Length)
{
  uint32 SpiCoreID;
  const struct Spi_ChannelConfigType * ChannelConfig;
  struct Spi_ChannelStateType * ChannelState;
  Std_ReturnType Status;
  Std_ReturnType D.6494;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = (int) Channel;
  ChannelState = &Spi_axSpiChannelState[_1];
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->ChannelConfig;
  _4 = (unsigned int) Channel;
  _5 = _4 * 4;
  _6 = _3 + _5;
  ChannelConfig = _6->ChannelCfg;
  _7 = ChannelConfig->BufferType;
  if (_7 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Status = 1;
  goto <bb 11>; [INV]

  <bb 4> :
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05 ();
  _8 = ChannelConfig->BufferDescriptor;
  _8->BufferTX = SrcDataBufferPtr;
  _9 = ChannelConfig->BufferDescriptor;
  _9->BufferRX = DesDataBufferPtr;
  ChannelState->Length = Length;
  if (SrcDataBufferPtr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _10 = ChannelState->Flags;
  _11 = _10 | 1;
  ChannelState->Flags = _11;
  goto <bb 7>; [INV]

  <bb 6> :
  _12 = ChannelState->Flags;
  _13 = _12 & 254;
  ChannelState->Flags = _13;

  <bb 7> :
  if (DesDataBufferPtr == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _14 = ChannelState->Flags;
  _15 = _14 | 2;
  ChannelState->Flags = _15;
  goto <bb 10>; [INV]

  <bb 9> :
  _16 = ChannelState->Flags;
  _17 = _16 & 253;
  ChannelState->Flags = _17;

  <bb 10> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05 ();

  <bb 11> :
  D.6494 = Status;

  <bb 12> :
<L9>:
  return D.6494;

}


Spi_ReadIB (Spi_ChannelType Channel, Spi_DataBufferType * DataBufferPointer)
{
  uint32 SpiCoreID;
  Spi_DataBufferType * DataBufferDes;
  const Spi_DataBufferType * pDataBufferSrc;
  const struct Spi_ChannelConfigType * ChannelConfig;
  Spi_NumberOfDataType Index;
  Std_ReturnType Status;
  Std_ReturnType D.6483;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->ChannelConfig;
  _3 = (unsigned int) Channel;
  _4 = _3 * 4;
  _5 = _2 + _4;
  ChannelConfig = _5->ChannelCfg;
  _6 = ChannelConfig->BufferType;
  if (_6 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Status = 1;
  goto <bb 9>; [INV]

  <bb 4> :
  if (DataBufferPointer == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Status = 1;
  goto <bb 9>; [INV]

  <bb 6> :
  _7 = ChannelConfig->BufferDescriptor;
  pDataBufferSrc = _7->BufferRX;
  DataBufferDes = DataBufferPointer;
  Index = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _8 = *pDataBufferSrc;
  *DataBufferDes = _8;
  DataBufferDes = DataBufferDes + 1;
  pDataBufferSrc = pDataBufferSrc + 1;
  Index.12_9 = Index;
  Index = Index.12_9 + 1;

  <bb 8> :
  _10 = ChannelConfig->Length;
  if (Index < _10)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.6483 = Status;

  <bb 10> :
<L9>:
  return D.6483;

}


Spi_AsyncTransmit (Spi_SequenceType Sequence)
{
  uint32 SpiCoreID;
  const Spi_JobType * JobCount;
  const Spi_JobType * Job;
  const struct Spi_JobConfigType * JobConfig;
  struct Spi_SequenceStateType * SequenceState;
  const struct Spi_SequenceConfigType * SequenceConfig;
  Spi_JobType JobId;
  Spi_JobType JobIndex;
  Spi_JobType NumJobsInSequence;
  Std_ReturnType Status;
  Std_ReturnType D.6466;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->SequenceConfig;
  _3 = (unsigned int) Sequence;
  _4 = _3 * 4;
  _5 = _2 + _4;
  SequenceConfig = _5->SeqConfig;
  NumJobsInSequence = SequenceConfig->NumJobs;
  JobIndex = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _6 = SequenceConfig->JobIndexList;
  _7 = (unsigned int) JobIndex;
  _8 = _7 * 2;
  _9 = _6 + _8;
  JobId = *_9;
  _10 = Spi_apxSpiConfigPtr[SpiCoreID];
  _11 = _10->JobConfig;
  _12 = (unsigned int) JobId;
  _13 = _12 * 4;
  _14 = _11 + _13;
  JobConfig = _14->JobCfg;
  JobIndex.10_15 = JobIndex;
  JobIndex = JobIndex.10_15 + 1;

  <bb 4> :
  if (JobIndex < NumJobsInSequence)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  Status = Spi_LockJobs (Sequence, SequenceConfig);
  if (Status == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _16 = (int) Sequence;
  SequenceState = &Spi_axSpiSequenceState[_16];
  SequenceState->Result = 1;
  _17 = SequenceConfig->NumJobs;
  _18 = _17 + 65535;
  SequenceState->RemainingJobs = _18;
  Job = SequenceConfig->JobIndexList;
  SequenceState->CurrentJobIndexPointer = Job;
  JobIndex = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _19 = SequenceConfig->JobIndexList;
  _20 = (unsigned int) JobIndex;
  _21 = _20 * 2;
  JobCount = _19 + _21;
  _22 = *JobCount;
  _23 = (int) _22;
  Spi_axSpiJobState[_23].Result = 3;
  JobIndex.11_24 = JobIndex;
  JobIndex = JobIndex.11_24 + 1;

  <bb 8> :
  if (JobIndex < NumJobsInSequence)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _25 = Spi_apxSpiConfigPtr[SpiCoreID];
  _26 = _25->JobConfig;
  _27 = *Job;
  _28 = (unsigned int) _27;
  _29 = _28 * 4;
  _30 = _26 + _29;
  JobConfig = _30->JobCfg;
  _31 = JobConfig->HWUnit;
  _32 = (int) _31;
  _33 = &Spi_axSpiHwUnitQueueArray[_32];
  _34 = *Job;
  Spi_ScheduleJob (_33, _34, JobConfig);
  goto <bb 11>; [INV]

  <bb 10> :
  Det_ReportRuntimeError (83, 0, 3, 42);

  <bb 11> :
  D.6466 = Status;

  <bb 12> :
<L9>:
  return D.6466;

}


Spi_WriteIB (Spi_ChannelType Channel, const Spi_DataBufferType * DataBufferPtr)
{
  uint32 SpiCoreID;
  const Spi_DataBufferType * DataBufferSrc;
  Spi_DataBufferType * DataBufferDes;
  const struct Spi_ChannelConfigType * ChannelConfig;
  struct Spi_ChannelStateType * ChannelState;
  uint16 Index;
  Std_ReturnType Status;
  Std_ReturnType D.6461;

  <bb 2> :
  Status = 0;
  SpiCoreID = 0;
  _1 = (int) Channel;
  ChannelState = &Spi_axSpiChannelState[_1];
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->ChannelConfig;
  _4 = (unsigned int) Channel;
  _5 = _4 * 4;
  _6 = _3 + _5;
  ChannelConfig = _6->ChannelCfg;
  _7 = ChannelConfig->BufferType;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Status = 1;
  goto <bb 11>; [INV]

  <bb 4> :
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04 ();
  if (DataBufferPtr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _8 = ChannelState->Flags;
  _9 = _8 | 1;
  ChannelState->Flags = _9;
  goto <bb 10>; [INV]

  <bb 6> :
  _10 = ChannelConfig->BufferDescriptor;
  DataBufferDes = _10->BufferTX;
  DataBufferSrc = DataBufferPtr;
  Index = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _11 = *DataBufferSrc;
  *DataBufferDes = _11;
  DataBufferDes = DataBufferDes + 1;
  DataBufferSrc = DataBufferSrc + 1;
  Index.9_12 = Index;
  Index = Index.9_12 + 1;

  <bb 8> :
  _13 = ChannelConfig->Length;
  if (Index < _13)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _14 = ChannelState->Flags;
  _15 = _14 & 254;
  ChannelState->Flags = _15;

  <bb 10> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04 ();

  <bb 11> :
  D.6461 = Status;

  <bb 12> :
<L9>:
  return D.6461;

}


Spi_DeInit ()
{
  uint32 SpiCoreID;
  Spi_HWUnitType HWUnit;
  Std_ReturnType TempExit;
  Std_ReturnType D.6453;

  <bb 2> :
  TempExit = 0;
  SpiCoreID = 0;
  _1 = Spi_GetStatus ();
  if (_1 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  TempExit = 1;
  goto <bb 11>; [INV]

  <bb 4> :
  HWUnit = 0;
  goto <bb 9>; [INV]

  <bb 5> :
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->HWUnitConfig;
  _4 = (unsigned int) HWUnit;
  _5 = _4 * 4;
  _6 = _3 + _5;
  _7 = _6->PhyUnitConfig;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _8 = Spi_apxSpiConfigPtr[SpiCoreID];
  _9 = _8->HWUnitConfig;
  _10 = (unsigned int) HWUnit;
  _11 = _10 * 4;
  _12 = _9 + _11;
  _13 = _12->PhyUnitConfig;
  _14 = _13->SpiCoreUse;
  if (SpiCoreID == _14)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Spi_Ipw_DeInit (HWUnit, SpiCoreID);
  _15 = (int) HWUnit;
  Spi_axSpiHwUnitQueueArray[_15].Status = 0;

  <bb 8> :
  HWUnit.8_16 = HWUnit;
  HWUnit = HWUnit.8_16 + 1;

  <bb 9> :
  if (HWUnit <= 2)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  Spi_apxSpiConfigPtr[SpiCoreID] = 0B;

  <bb 11> :
  D.6453 = TempExit;

  <bb 12> :
<L11>:
  return D.6453;

}


Spi_Init (const struct Spi_ConfigType * ConfigPtr)
{
  Std_ReturnType CheckStatus;
  uint32 SpiCoreID;
  Spi_HWUnitType HWUnit;

  <bb 2> :
  CheckStatus = 0;
  SpiCoreID = 0;
  CheckStatus = Spi_CheckInit (ConfigPtr, SpiCoreID);
  if (CheckStatus == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  Spi_apxSpiConfigPtr[SpiCoreID] = ConfigPtr;
  Spi_InitChannelsJobsSeqsState (SpiCoreID);
  HWUnit = 0;
  goto <bb 8>; [INV]

  <bb 4> :
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->HWUnitConfig;
  _3 = (unsigned int) HWUnit;
  _4 = _3 * 4;
  _5 = _2 + _4;
  _6 = _5->PhyUnitConfig;
  if (_6 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _7 = Spi_apxSpiConfigPtr[SpiCoreID];
  _8 = _7->HWUnitConfig;
  _9 = (unsigned int) HWUnit;
  _10 = _9 * 4;
  _11 = _8 + _10;
  _12 = _11->PhyUnitConfig;
  _13 = _12->SpiCoreUse;
  if (SpiCoreID == _13)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _14 = Spi_apxSpiConfigPtr[SpiCoreID];
  _15 = _14->HWUnitConfig;
  _16 = (unsigned int) HWUnit;
  _17 = _16 * 4;
  _18 = _15 + _17;
  _19 = _18->PhyUnitConfig;
  Spi_Ipw_Init (HWUnit, _19);
  Spi_Ipw_IrqConfig (HWUnit, 0, SpiCoreID);
  _20 = (long unsigned int) HWUnit;
  Spi_InitJobsList (_20);
  _21 = (int) HWUnit;
  Spi_axSpiHwUnitQueueArray[_21].Status = 1;

  <bb 7> :
  HWUnit.7_22 = HWUnit;
  HWUnit = HWUnit.7_22 + 1;

  <bb 8> :
  if (HWUnit <= 2)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}


Spi_GetVersionInfo (struct Std_VersionInfoType * versioninfo)
{
  <bb 2> :
  versioninfo->vendorID = 43;
  versioninfo->moduleID = 83;
  versioninfo->sw_major_version = 1;
  versioninfo->sw_minor_version = 0;
  versioninfo->sw_patch_version = 1;
  return;

}


Spi_LockJobsProcess (Spi_SequenceType SequenceId, const struct Spi_SequenceConfigType * Sequence, Spi_JobType JobCount)
{
  struct Spi_SequenceStateType * SequenceState;
  const Spi_JobType * Jobs;
  struct Spi_JobStateType * JobState;
  Spi_JobType JobCountProcess;
  Std_ReturnType Status;
  Std_ReturnType D.6428;

  <bb 2> :
  Status = 0;
  JobCountProcess = JobCount;
  Jobs = Sequence->JobIndexList;
  _1 = (int) SequenceId;
  SequenceState = &Spi_axSpiSequenceState[_1];
  goto <bb 9>; [INV]

  <bb 3> :
  _2 = *Jobs;
  _3 = (int) _2;
  JobState = &Spi_axSpiJobState[_3];
  _4 = JobState->AsyncCrtSequenceState;
  if (_4 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  JobState->AsyncCrtSequenceState = SequenceState;
  goto <bb 8>; [INV]

  <bb 5> :
  _5 = Sequence->NumJobs;
  if (JobCountProcess < _5)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  JobCountProcess.5_6 = JobCountProcess;
  JobCountProcess = JobCountProcess.5_6 + 1;
  Jobs = Jobs + 4294967294;
  _7 = *Jobs;
  _8 = (int) _7;
  Spi_axSpiJobState[_8].AsyncCrtSequenceState = 0B;
  _9 = Sequence->NumJobs;
  if (JobCountProcess < _9)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  Status = 1;
  goto <bb 10>; [INV]

  <bb 8> :
  JobCountProcess.6_10 = JobCountProcess;
  JobCountProcess = JobCountProcess.6_10 + 65535;
  Jobs = Jobs + 2;

  <bb 9> :
  if (JobCountProcess != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  D.6428 = Status;

  <bb 11> :
<L11>:
  return D.6428;

}


Spi_GetStatusAsyncCheckHwBusy (uint32 SpiCoreID)
{
  Spi_HWUnitType HWUnit;
  Spi_StatusType StatusFlag;
  Spi_StatusType D.6420;

  <bb 2> :
  StatusFlag = 1;
  HWUnit = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->HWUnitConfig;
  _3 = (unsigned int) HWUnit;
  _4 = _3 * 4;
  _5 = _2 + _4;
  _6 = _5->PhyUnitConfig;
  if (_6 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _7 = Spi_apxSpiConfigPtr[SpiCoreID];
  _8 = _7->HWUnitConfig;
  _9 = (unsigned int) HWUnit;
  _10 = _9 * 4;
  _11 = _8 + _10;
  _12 = _11->PhyUnitConfig;
  _13 = _12->SpiCoreUse;
  if (SpiCoreID == _13)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _14 = (int) HWUnit;
  _15 = Spi_axSpiHwUnitQueueArray[_14].Status;
  if (_15 == 2)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  StatusFlag = 2;
  goto <bb 9>; [INV]

  <bb 7> :
  HWUnit.4_16 = HWUnit;
  HWUnit = HWUnit.4_16 + 1;

  <bb 8> :
  if (HWUnit <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.6420 = StatusFlag;

  <bb 10> :
<L10>:
  return D.6420;

}


Spi_InitJobsList (uint32 HWUnit)
{
  sint8 Priority;

  <bb 2> :
  Priority = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (int) Priority;
  Spi_axSpiHwUnitQueueArray[HWUnit].ScheduledJobsListHead[_1] = 65535;
  _2 = (int) Priority;
  Spi_axSpiHwUnitQueueArray[HWUnit].ScheduledJobsListTail[_2] = 65535;
  Priority.2_3 = Priority;
  Priority.3_4 = (unsigned char) Priority.2_3;
  _5 = Priority.3_4 + 1;
  Priority = (sint8) _5;

  <bb 4> :
  if (Priority <= 3)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  Spi_axSpiHwUnitQueueArray[HWUnit].MaxScheduledPriority = -1;
  return;

}


Spi_InitChannelsJobsSeqsState (uint32 SpiCoreID)
{
  const struct Spi_SequenceConfigType * SequenceConfig;
  const struct Spi_JobConfigType * JobConfig;
  const struct Spi_ChannelConfigType * ChannelConfig;
  uint32 Sequence;
  uint32 Job;
  uint32 Channel;

  <bb 2> :
  Channel = 0;
  goto <bb 10>; [INV]

  <bb 3> :
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  _2 = _1->ChannelConfig;
  _3 = Channel * 4;
  _4 = _2 + _3;
  ChannelConfig = _4->ChannelCfg;
  if (ChannelConfig != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  _5 = ChannelConfig->SpiCoreUse;
  if (SpiCoreID == _5)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _6 = ChannelConfig->BufferType;
  if (_6 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _7 = ChannelConfig->BufferDescriptor;
  _7->BufferTX = 0B;
  _8 = ChannelConfig->BufferDescriptor;
  _8->BufferRX = 0B;
  Spi_axSpiChannelState[Channel].Length = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _9 = ChannelConfig->Length;
  Spi_axSpiChannelState[Channel].Length = _9;

  <bb 8> :
  Spi_axSpiChannelState[Channel].Flags = 1;

  <bb 9> :
  Channel = Channel + 1;

  <bb 10> :
  _10 = Spi_apxSpiConfigPtr[SpiCoreID];
  _11 = _10->SpiMaxChannel;
  _12 = (long unsigned int) _11;
  if (Channel <= _12)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  Job = 0;
  goto <bb 16>; [INV]

  <bb 12> :
  _13 = Spi_apxSpiConfigPtr[SpiCoreID];
  _14 = _13->JobConfig;
  _15 = Job * 4;
  _16 = _14 + _15;
  JobConfig = _16->JobCfg;
  if (JobConfig != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _17 = JobConfig->SpiCoreUse;
  if (SpiCoreID == _17)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  Spi_axSpiJobState[Job].Result = 0;
  Spi_axSpiJobState[Job].AsyncCrtSequenceState = 0B;

  <bb 15> :
  Job = Job + 1;

  <bb 16> :
  _18 = Spi_apxSpiConfigPtr[SpiCoreID];
  _19 = _18->SpiMaxJob;
  _20 = (long unsigned int) _19;
  if (Job <= _20)
    goto <bb 12>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  Sequence = 0;
  goto <bb 22>; [INV]

  <bb 18> :
  _21 = Spi_apxSpiConfigPtr[SpiCoreID];
  _22 = _21->SequenceConfig;
  _23 = Sequence * 4;
  _24 = _22 + _23;
  SequenceConfig = _24->SeqConfig;
  if (SequenceConfig != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _25 = SequenceConfig->SpiCoreUse;
  if (SpiCoreID == _25)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _26 = Spi_apxSpiConfigPtr[SpiCoreID];
  _27 = _26->SequenceConfig;
  _28 = Sequence * 4;
  _29 = _27 + _28;
  SequenceConfig = _29->SeqConfig;
  Spi_axSpiSequenceState[Sequence].Sequence = SequenceConfig;
  Spi_axSpiSequenceState[Sequence].Result = 0;
  Spi_au32SpiSeqUsedHWUnits[Sequence] = 4294967295;

  <bb 21> :
  Sequence = Sequence + 1;

  <bb 22> :
  _30 = Spi_apxSpiConfigPtr[SpiCoreID];
  _31 = _30->SpiMaxSequence;
  _32 = (long unsigned int) _31;
  if (Sequence <= _32)
    goto <bb 18>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  return;

}


Spi_SyncJobsTranfer (const struct Spi_SequenceConfigType * SequenceConfig, uint32 SpiCoreID)
{
  Std_ReturnType Status;
  const struct Spi_JobConfigType * JobConfig;
  struct Spi_JobStateType * JobState;
  Spi_JobType Job;
  const Spi_JobType * JobIndexList;
  Spi_JobType JobsCount;
  Std_ReturnType D.6395;

  <bb 2> :
  Status = 0;
  JobsCount = SequenceConfig->NumJobs;
  JobIndexList = SequenceConfig->JobIndexList;
  goto <bb 13>; [INV]

  <bb 3> :
  Job = *JobIndexList;
  _1 = (int) Job;
  JobState = &Spi_axSpiJobState[_1];
  JobState->Result = 1;
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->JobConfig;
  _4 = (unsigned int) Job;
  _5 = _4 * 4;
  _6 = _3 + _5;
  JobConfig = _6->JobCfg;
  _7 = JobConfig->StartNotification;
  if (_7 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _8 = JobConfig->StartNotification;
  _8 ();

  <bb 5> :
  _9 = JobConfig->HWUnit;
  _10 = (int) _9;
  Spi_axSpiHwUnitQueueArray[_10].Status = 2;
  Status = Spi_Ipw_SyncTransmit (JobConfig, SpiCoreID);
  _11 = JobConfig->HWUnit;
  _12 = (int) _11;
  Spi_axSpiHwUnitQueueArray[_12].Status = 1;
  if (Status == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  JobState->Result = 0;
  _13 = JobConfig->EndNotification;
  if (_13 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 7> :
  _14 = JobConfig->EndNotification;
  _14 ();
  goto <bb 12>; [INV]

  <bb 8> :
  _15 = *JobIndexList;
  _16 = (int) _15;
  Spi_axSpiJobState[_16].Result = 2;
  _17 = Spi_apxSpiConfigPtr[SpiCoreID];
  _18 = _17->JobConfig;
  _19 = *JobIndexList;
  _20 = (unsigned int) _19;
  _21 = _20 * 4;
  _22 = _18 + _21;
  JobConfig = _22->JobCfg;
  _23 = JobConfig->EndNotification;
  if (_23 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _24 = JobConfig->EndNotification;
  _24 ();

  <bb 10> :
  JobIndexList = JobIndexList + 2;
  JobsCount.0_25 = JobsCount;
  JobsCount = JobsCount.0_25 + 65535;
  if (JobsCount != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  JobsCount = 1;

  <bb 12> :
  JobIndexList = JobIndexList + 2;
  JobsCount.1_26 = JobsCount;
  JobsCount = JobsCount.1_26 + 65535;

  <bb 13> :
  if (JobsCount != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  D.6395 = Status;

  <bb 15> :
<L17>:
  return D.6395;

}


Spi_ScheduleJob (struct Spi_HWUnitQueue * HWUnitQueue, Spi_JobType Job, const struct Spi_JobConfigType * JobConfig)
{
  Spi_JobType * JobListTail;
  sint8 Priority;

  <bb 2> :
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00 ();
  _1 = HWUnitQueue->Status;
  if (_1 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  HWUnitQueue->Status = 2;
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00 ();
  _2 = (int) Job;
  Spi_axSpiJobState[_2].Result = 1;
  HWUnitQueue->Channel = 0;
  HWUnitQueue->Job = Job;
  Spi_Ipw_JobTransfer (JobConfig);
  goto <bb 10>; [INV]

  <bb 4> :
  Priority = JobConfig->Priority;
  _3 = (int) Priority;
  JobListTail = &HWUnitQueue->ScheduledJobsListTail[_3];
  _4 = *JobListTail;
  if (_4 == 65535)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _5 = (int) Priority;
  HWUnitQueue->ScheduledJobsListHead[_5] = Job;
  goto <bb 7>; [INV]

  <bb 6> :
  _6 = *JobListTail;
  _7 = (int) _6;
  Spi_axSpiJobState[_7].AsyncNextJob = Job;

  <bb 7> :
  *JobListTail = Job;
  _8 = (int) Job;
  Spi_axSpiJobState[_8].AsyncNextJob = 65535;
  _9 = HWUnitQueue->MaxScheduledPriority;
  if (Priority > _9)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  HWUnitQueue->MaxScheduledPriority = Priority;

  <bb 9> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00 ();

  <bb 10> :
  return;

}


Spi_UnlockRemainingJobs (Spi_JobType RemainingJobs, const struct Spi_SequenceConfigType * Sequence)
{
  Spi_JobType JobIdx;
  Spi_JobType NumJobsInSeq;

  <bb 2> :
  NumJobsInSeq = Sequence->NumJobs;
  JobIdx = NumJobsInSeq - RemainingJobs;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = Sequence->JobIndexList;
  _2 = (unsigned int) JobIdx;
  _3 = _2 * 2;
  _4 = _1 + _3;
  _5 = *_4;
  _6 = (int) _5;
  Spi_axSpiJobState[_6].AsyncCrtSequenceState = 0B;
  JobIdx.23_7 = JobIdx;
  JobIdx = JobIdx.23_7 + 1;

  <bb 4> :
  if (JobIdx < NumJobsInSeq)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Spi_LockJobs (Spi_SequenceType SequenceId, const struct Spi_SequenceConfigType * Sequence)
{
  struct Spi_JobStateType * JobState;
  const Spi_JobType * Jobs;
  Spi_JobType JobCount;
  Std_ReturnType Status;
  Std_ReturnType D.6381;

  <bb 2> :
  Status = 0;
  JobCount = Sequence->NumJobs;
  Jobs = Sequence->JobIndexList;
  SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03 ();
  if (JobCount == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _1 = *Jobs;
  _2 = (int) _1;
  JobState = &Spi_axSpiJobState[_2];
  _3 = JobState->AsyncCrtSequenceState;
  if (_3 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _4 = (int) SequenceId;
  _5 = &Spi_axSpiSequenceState[_4];
  JobState->AsyncCrtSequenceState = _5;
  goto <bb 7>; [INV]

  <bb 5> :
  Status = 1;
  goto <bb 7>; [INV]

  <bb 6> :
  Status = Spi_LockJobsProcess (SequenceId, Sequence, JobCount);

  <bb 7> :
  SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03 ();
  D.6381 = Status;

  <bb 8> :
<L6>:
  return D.6381;

}


Spi_GetAsyncStatus ()
{
  uint32 SpiCoreID;
  Spi_HWUnitType HWUnit;
  Spi_StatusType StatusFlag;
  Spi_StatusType D.6555;

  <bb 2> :
  StatusFlag = 1;
  SpiCoreID = 0;
  _1 = Spi_apxSpiConfigPtr[SpiCoreID];
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 3> :
  HWUnit = 0;
  goto <bb 10>; [INV]

  <bb 4> :
  _2 = Spi_apxSpiConfigPtr[SpiCoreID];
  _3 = _2->HWUnitConfig;
  _4 = (unsigned int) HWUnit;
  _5 = _4 * 4;
  _6 = _3 + _5;
  _7 = _6->PhyUnitConfig;
  if (_7 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _8 = Spi_apxSpiConfigPtr[SpiCoreID];
  _9 = _8->HWUnitConfig;
  _10 = (unsigned int) HWUnit;
  _11 = _10 * 4;
  _12 = _9 + _11;
  _13 = _12->PhyUnitConfig;
  _14 = _13->SpiCoreUse;
  if (SpiCoreID == _14)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _15 = (int) HWUnit;
  _16 = Spi_axSpiHwUnitQueueArray[_15].Status;
  if (_16 == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _17 = Spi_apxSpiConfigPtr[SpiCoreID];
  _18 = _17->HWUnitConfig;
  _19 = (unsigned int) HWUnit;
  _20 = _19 * 4;
  _21 = _18 + _20;
  _22 = _21->PhyUnitConfig;
  _23 = _22->IsSync;
  if (_23 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  StatusFlag = 2;
  goto <bb 11>; [INV]

  <bb 9> :
  HWUnit.18_24 = HWUnit;
  HWUnit = HWUnit.18_24 + 1;

  <bb 10> :
  if (HWUnit <= 2)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :

  <bb 12> :
  D.6555 = StatusFlag;

  <bb 13> :
<L15>:
  return D.6555;

}


Spi_CheckInit (const struct Spi_ConfigType * ConfigPtr, uint32 SpiCoreID)
{
  uint32 Sequence;
  uint32 Job;
  uint32 Channel;
  Std_ReturnType CheckStatus;
  Std_ReturnType D.6443;

  <bb 2> :
  CheckStatus = 0;
  _1 = ConfigPtr->SpiMaxChannel;
  Channel = (uint32) _1;
  _2 = ConfigPtr->SpiMaxJob;
  Job = (uint32) _2;
  _3 = ConfigPtr->SpiMaxSequence;
  Sequence = (uint32) _3;
  if (Channel > 1)
    goto <bb 5>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (Job > 3)
    goto <bb 5>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  if (Sequence > 3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  CheckStatus = 1;

  <bb 6> :
  _4 = ConfigPtr->SpiCoreUse;
  if (SpiCoreID != _4)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  CheckStatus = 1;

  <bb 8> :
  D.6443 = CheckStatus;

  <bb 9> :
<L6>:
  return D.6443;

}


